<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1" />
		<title>Voxel Viewer</title>
		<style>
			html,
			body {
				height: 100%;
				margin: 0;
				background: #111;
				color: #eee;
				font-family: system-ui, -apple-system, sans-serif;
			}
			#hud {
				position: absolute;
				top: 8px;
				left: 8px;
				z-index: 10;
				background: rgba(0, 0, 0, 0.5);
				padding: 8px 10px;
				border-radius: 6px;
			}
			#file {
				display: inline-block;
			}
			#legend {
				position: absolute;
				bottom: 8px;
				left: 8px;
				color: #ccc;
				font-size: 12px;
			}
			canvas {
				display: block;
			}
		</style>
	</head>
	<body>
		<div id="hud">
			<div>
				<strong>Controls</strong>: drag to orbit, scroll to zoom, right-drag to
				pan
			</div>
			<div>
				Load: <input id="file" type="file" accept="application/json" /> or use
				default outputs/voxel_top_points.json
			</div>
		</div>
		<div id="legend"></div>
		<script type="importmap">
			{
				"imports": {
					"three": "https://unpkg.com/three@0.160.0/build/three.module.js"
				}
			}
		</script>
		<script type="module">
			import * as THREE from 'three';
			import { OrbitControls } from 'https://unpkg.com/three@0.160.0/examples/jsm/controls/OrbitControls.js';

			const scene = new THREE.Scene();
			scene.background = new THREE.Color(0x111111);
			const camera = new THREE.PerspectiveCamera(
				60,
				window.innerWidth / window.innerHeight,
				0.1,
				1e7
			);
			const renderer = new THREE.WebGLRenderer({ antialias: true });
			renderer.setSize(window.innerWidth, window.innerHeight);
			document.body.appendChild(renderer.domElement);
			const controls = new OrbitControls(camera, renderer.domElement);
			controls.enableDamping = true;

			const grid = new THREE.GridHelper(1000, 20, 0x555555, 0x333333);
			grid.rotateX(Math.PI / 2);
			scene.add(grid);

			const axes = new THREE.AxesHelper(300);
			scene.add(axes);

			camera.position.set(800, 600, 800);
			controls.target.set(0, 0, 0);
			controls.update();

			let cloudObj = null;
			const legend = document.getElementById('legend');

			async function loadDefault() {
				const candidates = [
					'/outputs/voxel_top_points.json',
					'../outputs/voxel_top_points.json',
					'voxel_top_points.json',
				];
				for (const url of candidates) {
					try {
						const res = await fetch(url, { cache: 'no-store' });
						if (!res.ok) throw new Error('not found');
						const data = await res.json();
						addPoints(data);
						return;
					} catch (e) {
						console.warn('fetch failed:', url, e);
					}
				}
				legend.textContent =
					'Select voxel_top_points.json via the file input above.';
			}

			function addPoints(data) {
				if (cloudObj) scene.remove(cloudObj);
				const N = data.length;
				const positions = new Float32Array(N * 3);
				const colors = new Float32Array(N * 3);
				let vmin = Infinity,
					vmax = -Infinity;
				for (const p of data) {
					vmin = Math.min(vmin, p.v);
					vmax = Math.max(vmax, p.v);
				}
				const col = new THREE.Color();
				for (let i = 0; i < N; i++) {
					const p = data[i];
					positions[3 * i + 0] = p.x;
					positions[3 * i + 1] = p.y;
					positions[3 * i + 2] = p.z;
					const t = (p.v - vmin) / Math.max(1e-9, vmax - vmin);
					col.setHSL((1.0 - t) * 0.1, 1.0, 0.5); // red/yellow heat
					colors[3 * i + 0] = col.r;
					colors[3 * i + 1] = col.g;
					colors[3 * i + 2] = col.b;
				}
				const geom = new THREE.BufferGeometry();
				geom.setAttribute('position', new THREE.BufferAttribute(positions, 3));
				geom.setAttribute('color', new THREE.BufferAttribute(colors, 3));
				const mat = new THREE.PointsMaterial({
					size: 4,
					vertexColors: true,
					opacity: 0.7,
					transparent: true,
				});
				cloudObj = new THREE.Points(geom, mat);
				scene.add(cloudObj);

				// Fit view
				geom.computeBoundingSphere();
				const bs = geom.boundingSphere;
				if (bs && isFinite(bs.radius) && bs.radius > 0) {
					camera.position.set(
						bs.center.x + bs.radius * 2.2,
						bs.center.y + bs.radius * 1.6,
						bs.center.z + bs.radius * 2.2
					);
					controls.target.copy(bs.center);
					controls.update();
				}
				legend.textContent = `Points: ${N}  value range: ${vmin.toFixed(
					2
				)} â€“ ${vmax.toFixed(2)}`;
			}

			document.getElementById('file').addEventListener('change', (ev) => {
				const f = ev.target.files && ev.target.files[0];
				if (!f) return;
				const reader = new FileReader();
				reader.onload = () => {
					try {
						const data = JSON.parse(reader.result);
						addPoints(data);
					} catch (e) {
						alert('Failed to parse JSON: ' + e.message);
					}
				};
				reader.readAsText(f);
			});

			function animate() {
				requestAnimationFrame(animate);
				controls.update();
				renderer.render(scene, camera);
			}
			animate();

			loadDefault();
			window.addEventListener('resize', () => {
				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();
				renderer.setSize(window.innerWidth, window.innerHeight);
			});
		</script>
	</body>
</html>
