<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1" />
		<title>Simulation - Tri-Rig Drone Dot</title>
		<style>
			html,
			body {
				height: 100%;
				margin: 0;
				background: #0f0f12;
				color: #eaeaea;
				font-family: system-ui, -apple-system, sans-serif;
			}
			#ui {
				position: absolute;
				top: 48px; /* leave space for flash marker */
				left: 10px;
				z-index: 10;
				background: rgba(0, 0, 0, 0.5);
				padding: 8px 10px;
				border-radius: 6px;
			}
			#flash {
				position: absolute;
				top: 10px;
				left: 10px;
				width: 24px;
				height: 24px;
				border-radius: 4px;
				background: #ffffff;
				opacity: 0;
				z-index: 11;
				box-shadow: 0 0 16px rgba(255, 255, 255, 0.8);
				transition: opacity 80ms ease;
			}
			#flash.on {
				opacity: 1;
			}
			button {
				margin-right: 6px;
			}
			#info {
				position: absolute;
				bottom: 10px;
				left: 10px;
				font-size: 12px;
				color: #ccc;
			}
		</style>
		<script type="importmap">
			{
				"imports": {
					"three": "https://unpkg.com/three@0.160.0/build/three.module.js"
				}
			}
		</script>
	</head>
	<body>
		<div id="flash"></div>
		<div id="ui">
			<button id="cam0">POV 0</button>
			<button id="cam1">POV 1</button>
			<button id="cam2">POV 2</button>
			<button id="top">Top</button>
			<button id="export">Export Config</button>
		</div>
		<div id="info">
			Tri-rig: cam0=(0,h,0), cam1=(B,h,0), cam2=(B/2,h,√3·B/2). Dot moves along
			a line in world space.
		</div>

		<script type="module">
			import * as THREE from 'three';
			import { OrbitControls } from 'https://unpkg.com/three@0.160.0/examples/jsm/controls/OrbitControls.js';

			const scene = new THREE.Scene();
			scene.background = new THREE.Color(0x0f0f12);
			// Use Z-up so XY is the ground plane
			THREE.Object3D.DEFAULT_UP.set(0, 0, 1);
			const camera = new THREE.PerspectiveCamera(
				60,
				window.innerWidth / window.innerHeight,
				0.1,
				1e7
			);
			const renderer = new THREE.WebGLRenderer({ antialias: true });
			renderer.setSize(window.innerWidth, window.innerHeight);
			document.body.appendChild(renderer.domElement);
			const controls = new OrbitControls(camera, renderer.domElement);
			controls.enableDamping = true;

			// XY plane highlight (semi-transparent)
			const grid = new THREE.GridHelper(2000, 80, 0x666666, 0x333333);
			grid.rotateX(Math.PI / 2); // place on XY plane at z=0
			scene.add(grid);
			const planeMat = new THREE.MeshBasicMaterial({
				color: 0x0a3a6a,
				transparent: true,
				opacity: 0.08,
				depthWrite: false,
			});
			const planeXY = new THREE.Mesh(
				new THREE.PlaneGeometry(2000, 2000),
				planeMat
			);
			planeXY.position.set(0, 0, 0);
			scene.add(planeXY);
			// Z axis line
			{
				const zGeom = new THREE.BufferGeometry().setFromPoints([
					new THREE.Vector3(0, 0, -1200),
					new THREE.Vector3(0, 0, 1200),
				]);
				const zLine = new THREE.Line(
					zGeom,
					new THREE.LineBasicMaterial({ color: 0x33ddff, linewidth: 2 })
				);
				scene.add(zLine);
			}

			// XYZ arrow helpers at origin (X=red, Y=green, Z=blue)
			const arrowLen = 300;
			const headLen = 60;
			const headWidth = 30;
			scene.add(
				new THREE.ArrowHelper(
					new THREE.Vector3(1, 0, 0),
					new THREE.Vector3(0, 0, 0),
					arrowLen,
					0xff5555,
					headLen,
					headWidth
				)
			);
			scene.add(
				new THREE.ArrowHelper(
					new THREE.Vector3(0, 1, 0),
					new THREE.Vector3(0, 0, 0),
					arrowLen,
					0x55ff55,
					headLen,
					headWidth
				)
			);
			scene.add(
				new THREE.ArrowHelper(
					new THREE.Vector3(0, 0, 1),
					new THREE.Vector3(0, 0, 0),
					arrowLen,
					0x5599ff,
					headLen,
					headWidth
				)
			);

			// Triangular rig parameters
			const B = 600; // baseline for POV placement across X
			const camHeight = 100; // low eye height along Z (up)
			const center = new THREE.Vector3(0, 0, 300); // focus along +Z, mid-screen
			// Z-up: positions (x, y, z). Place cameras behind at negative Y, same height z
			const camPos = [
				new THREE.Vector3(-B, -800, camHeight),
				new THREE.Vector3(0, -800, camHeight),
				new THREE.Vector3(B, -800, camHeight),
			];

			// Helper: set camera to POV i
			function setPOV(i) {
				const p = camPos[i].clone();
				camera.position.copy(p);
				camera.up.set(0, 0, 1); // Z-up
				camera.lookAt(center);
				controls.target.copy(center);
				controls.update();
			}

			// Moving dot (drone sprite)
			const sph = new THREE.Mesh(
				new THREE.SphereGeometry(8, 16, 12),
				new THREE.MeshBasicMaterial({ color: 0xffcc00 })
			);
			scene.add(sph);

			// Path: straight line across space
			const p0 = new THREE.Vector3(-200, 50, 50);
			const p1 = new THREE.Vector3(200, 80, 650);
			let t = 0;
			let playing = false;
			const durationSec = 8.0; // flight duration from p0 to p1
			let flightStart = 0; // ms timestamp

			function flash(color = '#ffffff') {
				const f = document.getElementById('flash');
				f.style.background = color;
				f.classList.add('on');
				setTimeout(() => f.classList.remove('on'), 180);
			}

			function startFlight() {
				t = 0;
				playing = true;
				flightStart = performance.now();
				flash('#ffffff'); // start marker
			}

			function updateDot(dt) {
				if (!playing) return;
				const elapsed = (performance.now() - flightStart) / 1000.0;
				t = Math.min(1.0, Math.max(0.0, elapsed / durationSec));
				sph.position.lerpVectors(p0, p1, t);
				if (t >= 1.0) {
					playing = false;
					flash('#ff3355'); // end marker
				}
			}

			// Buttons
			document.getElementById('cam0').onclick = () => {
				setPOV(0);
				startFlight();
			};
			document.getElementById('cam1').onclick = () => {
				setPOV(1);
				startFlight();
			};
			document.getElementById('cam2').onclick = () => {
				setPOV(2);
				startFlight();
			};
			document.getElementById('top').onclick = () => {
				camera.position.set(center.x, center.y + 1200, center.z);
				camera.lookAt(center);
				controls.target.copy(center);
				controls.update();
			};

			// Export camera rig (position + forward + up + FOV) as JSON
			document.getElementById('export').onclick = () => {
				const cams = camPos.map((p, i) => {
					const fwd = center.clone().sub(p).normalize();
					const up = new THREE.Vector3(0, 0, 1);
					return {
						name: `sim${i}`,
						position: [p.x, p.y, p.z],
						forward: [fwd.x, fwd.y, fwd.z],
						up: [up.x, up.y, up.z],
						fov_deg: 70,
					};
				});
				const payload = { coordinate_system: 'Z_up_XY_ground', cameras: cams };
				const blob = new Blob([JSON.stringify(payload, null, 2)], {
					type: 'application/json',
				});
				const a = document.createElement('a');
				a.href = URL.createObjectURL(blob);
				a.download = 'cam_config.json';
				a.click();
				URL.revokeObjectURL(a.href);
			};

			// Default ground-level perspective: Z-up, from negative Y, low height, looking toward +Z center
			camera.position.set(0, -900, camHeight + 40);
			camera.up.set(0, 0, 1);
			camera.lookAt(center);
			controls.target.copy(center);
			controls.update();

			let last = performance.now();
			function animate() {
				const now = performance.now();
				const dt = (now - last) / 1000.0;
				last = now;
				updateDot(dt);
				controls.update();
				renderer.render(scene, camera);
				requestAnimationFrame(animate);
			}
			animate();

			window.addEventListener('resize', () => {
				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();
				renderer.setSize(window.innerWidth, window.innerHeight);
			});
		</script>
	</body>
</html>
