<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1" />
		<title>Track Viewer</title>
		<style>
			html,
			body {
				height: 100%;
				margin: 0;
				background: #0f0f12;
				color: #eaeaea;
				font-family: system-ui, -apple-system, sans-serif;
			}
			#hud {
				position: absolute;
				top: 10px;
				left: 10px;
				background: rgba(0, 0, 0, 0.5);
				padding: 8px 10px;
				border-radius: 6px;
				z-index: 10;
			}
			/* removed separate #ui container; controls are combined under #hud */
			/* Stack controls in HUD to avoid overlap */
			#hud input[type='file'],
			#hud select,
			#hud button {
				display: block;
				margin-top: 6px;
			}
			button {
				margin-right: 6px;
				border: 1px solid #444;
				background: #333;
				color: #eee;
				padding: 4px 8px;
				border-radius: 3px;
				cursor: pointer;
			}
			button:hover {
				background: #444;
			}
			/* unified save button */
			.save-btn {
				border-color: #777;
				background: #555;
				color: #eee;
			}
			.setup3-btn {
				border-color: #00aaff;
				background: #004466;
			}
			.setup3-btn:hover {
				background: #006688;
			}
			.setup4-btn {
				border-color: #ff4444;
				background: #661a1a;
			}
			.setup4-btn:hover {
				background: #882222;
			}
			#flash {
				position: absolute;
				top: 10px;
				left: 10px;
				width: 24px;
				height: 24px;
				border-radius: 4px;
				background: #ffffff;
				opacity: 0;
				z-index: 11;
				box-shadow: 0 0 16px rgba(255, 255, 255, 0.8);
				transition: opacity 80ms ease;
			}
			#flash.on {
				opacity: 1;
			}
			#legend {
				margin-top: 8px;
				font-size: 12px;
				color: #bbb;
			}
			.legend-row {
				display: flex;
				align-items: center;
				margin-top: 4px;
			}
			.swatch {
				width: 12px;
				height: 12px;
				border-radius: 50%;
				margin-right: 6px;
				display: inline-block;
			}
		</style>
		<script type="importmap">
			{
				"imports": {
					"three": "https://unpkg.com/three@0.160.0/build/three.module.js"
				}
			}
		</script>
	</head>
	<body>
		<div id="flash"></div>
		<div id="hud">
			Load track JSONs
			<input id="file" type="file" accept="application/json" multiple />
			<div style="margin-top: 8px; font-size: 12px; color: #bbb">Scenario:</div>
			<select id="scenario">
				<option value="straight">A - Straight path</option>
				<option value="curved">B - Curved path</option>
				<option value="curved3">C - 3 objects (curved)</option>
			</select>
			<label
				id="includeSimRow"
				style="display: none; margin-top: 6px; font-size: 12px; color: #bbb"
			>
				<input id="includeSim" type="checkbox" /> Include simulation
			</label>
			<label
				id="pathsRow"
				style="margin-top: 6px; font-size: 12px; color: #bbb"
			>
				<input id="showPaths" type="checkbox" /> Show flight paths
			</label>
			<button id="start">Start flight</button>
			<div id="trackList" style="margin-top: 10px; font-size: 12px"></div>
			<div id="legend">
				<div class="legend-row">
					<span class="swatch" style="background: #ff5555"></span> Simulation
				</div>
				<div class="legend-row">
					<span class="swatch" style="background: #55ffcc"></span>
					Reconstruction
				</div>
			</div>
		</div>
		<script type="module">
			import * as THREE from 'three';
			import { OrbitControls } from 'https://unpkg.com/three@0.160.0/examples/jsm/controls/OrbitControls.js';

			THREE.Object3D.DEFAULT_UP.set(0, 0, 1);
			const scene = new THREE.Scene();
			scene.background = new THREE.Color(0x0f0f12);
			const camera = new THREE.PerspectiveCamera(
				60,
				innerWidth / innerHeight,
				0.1,
				1e7
			);
			const renderer = new THREE.WebGLRenderer({ antialias: true });
			renderer.setSize(innerWidth, innerHeight);
			document.body.appendChild(renderer.domElement);
			const controls = new OrbitControls(camera, renderer.domElement);
			controls.enableDamping = true;

			const grid = new THREE.GridHelper(2000, 80, 0x666666, 0x333333);
			grid.rotateX(Math.PI / 2);
			scene.add(grid);
			const plane = new THREE.Mesh(
				new THREE.PlaneGeometry(2000, 2000),
				new THREE.MeshBasicMaterial({
					color: 0x0a3a6a,
					transparent: true,
					opacity: 0.08,
				})
			);
			scene.add(plane);
			scene.add(
				new THREE.ArrowHelper(
					new THREE.Vector3(1, 0, 0),
					new THREE.Vector3(0, 0, 0),
					300,
					0xff5555,
					60,
					30
				)
			);
			scene.add(
				new THREE.ArrowHelper(
					new THREE.Vector3(0, 1, 0),
					new THREE.Vector3(0, 0, 0),
					300,
					0x55ff55,
					60,
					30
				)
			);
			scene.add(
				new THREE.ArrowHelper(
					new THREE.Vector3(0, 0, 1),
					new THREE.Vector3(0, 0, 0),
					300,
					0x5599ff,
					60,
					30
				)
			);

			camera.position.set(0, -900, 200);
			camera.lookAt(0, 0, 300);

			// removed standalone dot: reconstruction uses fileActors, simulation uses simActors

			// --- Loaded track playback (supports single or multiple tracks) ---
			let fileTracks = [];
			let fileMeta = [];
			let fileActors = [];
			let filePathLines = [];
			let fileIdx = 0;
			let fileMaxLen = 0;
			let filePlaybackFps = 30;
			let fileAcc = 0;
			let filePlaying = false;
			function clearFileActors() {
				for (const m of fileActors) {
					if (m && m.parent) m.parent.remove(m);
				}
				fileActors = [];
				for (const l of filePathLines) {
					if (l && l.parent) l.parent.remove(l);
				}
				filePathLines = [];
			}
			function ensureFileActors() {
				while (fileActors.length < fileTracks.length) {
					const idx = fileActors.length;
					const color = fileMeta[idx]?.color || 0x55ffcc;
					const m = new THREE.Mesh(
						new THREE.SphereGeometry(8, 16, 12),
						new THREE.MeshBasicMaterial({ color })
					);
					scene.add(m);
					fileActors.push(m);
				}
				for (let i = 0; i < fileActors.length; i++) {
					fileActors[i].visible = Boolean(fileMeta[i]?.visible);
					if (fileMeta[i]?.color && fileActors[i]?.material)
						fileActors[i].material.color = new THREE.Color(fileMeta[i].color);
				}
			}

			function buildFilePaths() {
				// Remove existing
				for (const l of filePathLines) {
					if (l && l.parent) l.parent.remove(l);
				}
				filePathLines = [];
				const show = document.getElementById('showPaths')?.checked;
				if (!show) return;
				for (let i = 0; i < fileTracks.length; i++) {
					const tr = fileTracks[i];
					if (!tr || tr.length < 2) continue;
					if (!fileMeta[i]?.visible) continue;
					const pts = [];
					for (const p of tr) {
						pts.push(new THREE.Vector3(p.x, p.y, p.z));
					}
					const geom = new THREE.BufferGeometry().setFromPoints(pts);
					const color = fileMeta[i]?.color || 0x55ffcc;
					const mat = new THREE.LineBasicMaterial({ color, linewidth: 2 });
					const line = new THREE.Line(geom, mat);
					scene.add(line);
					filePathLines.push(line);
				}
			}

			function rebuildTrackListUI() {
				const list = document.getElementById('trackList');
				if (!list) return;
				list.innerHTML = '';
				for (let i = 0; i < fileTracks.length; i++) {
					const row = document.createElement('div');
					row.style.display = 'flex';
					row.style.alignItems = 'center';
					row.style.marginTop = '4px';
					const sw = document.createElement('span');
					sw.className = 'swatch';
					sw.style.background = new THREE.Color(
						fileMeta[i]?.color || 0x55ffcc
					).getStyle();
					row.appendChild(sw);
					const label = document.createElement('span');
					label.textContent = fileMeta[i]?.name || `Track ${i + 1}`;
					label.style.marginRight = '8px';
					row.appendChild(label);
					const vis = document.createElement('input');
					vis.type = 'checkbox';
					vis.checked = Boolean(fileMeta[i]?.visible);
					vis.onchange = () => {
						fileMeta[i].visible = vis.checked;
						ensureFileActors();
						buildFilePaths();
					};
					row.appendChild(vis);
					const rm = document.createElement('button');
					rm.textContent = 'Remove';
					rm.style.marginLeft = '6px';
					rm.onclick = () => {
						if (fileActors[i] && fileActors[i].parent)
							fileActors[i].parent.remove(fileActors[i]);
						fileActors.splice(i, 1);
						if (filePathLines[i] && filePathLines[i].parent)
							filePathLines[i].parent.remove(filePathLines[i]);
						filePathLines.splice(i, 1);
						fileTracks.splice(i, 1);
						fileMeta.splice(i, 1);
						fileMaxLen = fileTracks.reduce((m, t) => Math.max(m, t.length), 0);
						rebuildTrackListUI();
						ensureFileActors();
						buildFilePaths();
					};
					row.appendChild(rm);
					list.appendChild(row);
				}
			}

			const palette = [
				0x55ffcc, 0x33ddaa, 0x88ffee, 0x22aa88, 0xbbffee, 0x99ffdd, 0xffdd55,
				0xffaa88, 0xaaddff,
			];
			function nextColor(idx) {
				return palette[idx % palette.length];
			}
			function addTracksFromData(name, data) {
				let tracks = [];
				if (Array.isArray(data)) {
					tracks = [data];
				} else if (data && Array.isArray(data.tracks)) {
					tracks = data.tracks.map((t) =>
						Array.isArray(t) ? t : t.points || []
					);
				} else {
					return false;
				}
				for (let k = 0; k < tracks.length; k++) {
					const idx = fileTracks.length;
					fileTracks.push(tracks[k]);
					fileMeta.push({
						name: tracks.length > 1 ? `${name}[${k}]` : name,
						color: nextColor(idx),
						visible: true,
					});
				}
				fileMaxLen = fileTracks.reduce((m, t) => Math.max(m, t.length), 0);
				ensureFileActors();
				buildFilePaths();
				rebuildTrackListUI();
				return true;
			}

			// --- Simulation scenarios (procedural flight) ---
			let simActors = []; // { mesh, pathFn }
			let simPathLines = [];
			let simPlaying = false;
			let simStart = 0;
			let simDurationSec = 8.0;
			function clearSimActors() {
				for (const a of simActors) {
					if (a.mesh && a.mesh.parent) a.mesh.parent.remove(a.mesh);
				}
				simActors = [];
				for (const l of simPathLines) {
					if (l && l.parent) l.parent.remove(l);
				}
				simPathLines = [];
			}
			function addActor(color = 0xffcc00, size = 8) {
				const m = new THREE.Mesh(
					new THREE.SphereGeometry(size, 16, 12),
					new THREE.MeshBasicMaterial({ color })
				);
				scene.add(m);
				return m;
			}
			function buildScenario(name) {
				clearSimActors();
				simDurationSec = 8.0;
				if (name === 'straight') {
					const m = addActor(0xff5555, 8);
					const p0 = new THREE.Vector3(-200, 50, 50);
					const p1 = new THREE.Vector3(200, 80, 650);
					simActors.push({
						mesh: m,
						pathFn: (t) => new THREE.Vector3().lerpVectors(p0, p1, t),
					});
				} else if (name === 'curved') {
					const m = addActor(0xff5555, 8);
					simActors.push({
						mesh: m,
						pathFn: (t) => {
							const x = -250 + 500 * t;
							const y = 80 + 100 * Math.sin(Math.PI * 1.5 * t);
							const z = 100 + 520 * t + 80 * Math.sin(Math.PI * 2 * t);
							return new THREE.Vector3(x, y, z);
						},
					});
				} else if (name === 'curved3') {
					const m1 = addActor(0xff5555, 8);
					const m2 = addActor(0xff5555, 8);
					const m3 = addActor(0xff5555, 8);
					// Two similar paths side-by-side (Y offset)
					simActors.push({
						mesh: m1,
						pathFn: (t) => {
							const x = -260 + 520 * t;
							const y = 60 + 90 * Math.sin(Math.PI * 1.6 * t) + 40;
							const z = 90 + 540 * t + 70 * Math.sin(Math.PI * 2.2 * t);
							return new THREE.Vector3(x, y, z);
						},
					});
					simActors.push({
						mesh: m2,
						pathFn: (t) => {
							const x = -260 + 520 * t;
							const y = 60 + 90 * Math.sin(Math.PI * 1.6 * t) - 40;
							const z = 90 + 540 * t + 70 * Math.sin(Math.PI * 2.2 * t);
							return new THREE.Vector3(x, y, z);
						},
					});
					// Third different path
					simActors.push({
						mesh: m3,
						pathFn: (t) => {
							const x = -300 + 600 * t;
							const y = 50 - 120 * Math.cos(Math.PI * t);
							const z = 80 + 520 * t + 120 * Math.sin(Math.PI * 1.2 * t);
							return new THREE.Vector3(x, y, z);
						},
					});
					simDurationSec = 9.0;
				} else {
					// default to straight
					return buildScenario('straight');
				}
			}

			function buildSimPaths() {
				for (const l of simPathLines) {
					if (l && l.parent) l.parent.remove(l);
				}
				simPathLines = [];
				const show = document.getElementById('showPaths')?.checked;
				if (!show) return;
				// Bake ~200 points along each sim path
				const SAMPLES = 200;
				for (const a of simActors) {
					const pts = [];
					for (let i = 0; i <= SAMPLES; i++) {
						const t = i / SAMPLES;
						const p = a.pathFn(t);
						if (p) pts.push(p.clone());
					}
					if (pts.length >= 2) {
						const geom = new THREE.BufferGeometry().setFromPoints(pts);
						const mat = new THREE.LineBasicMaterial({
							color: 0xff5555,
							linewidth: 2,
						});
						const line = new THREE.Line(geom, mat);
						scene.add(line);
						simPathLines.push(line);
					}
				}
			}
			function flash(color = '#ffffff') {
				const f = document.getElementById('flash');
				f.style.background = color;
				f.classList.add('on');
				setTimeout(() => f.classList.remove('on'), 180);
			}
			function startFlight() {
				const sel = document.getElementById('scenario');
				const includeSim = document.getElementById('includeSim');
				const includeSimRow = document.getElementById('includeSimRow');
				const name = sel ? sel.value : 'straight';
				const hasTracks = fileTracks.length > 0;
				const shouldPlaySim = hasTracks
					? includeSim && includeSim.checked
					: true;
				if (shouldPlaySim) {
					buildScenario(name);
					simStart = performance.now();
					simPlaying = true;
					flash('#ffffff');
					buildSimPaths();
				} else {
					clearSimActors();
					simPlaying = false;
				}
				if (hasTracks) {
					fileIdx = 0;
					fileAcc = 0;
					ensureFileActors(fileTracks.length);
					filePlaying = true;
					buildFilePaths();
				}
				// Hide sim include when there is no track
				includeSimRow.style.display = hasTracks ? 'block' : 'none';
			}

			// --- POV integration from Simulation ---
			// Removed Setup 1 and 2
			const center = new THREE.Vector3(0, 0, 300);
			const setup3Arrows = [];
			const setup4Arrows = [];
			// Setup 4 (customizable): parameters and positions
			let setup4 = {
				heightZ: 120,
				distanceBetween: 600,
				flareAngleDeg: 30, // angle of left/right outward from center direction
				distanceToCenter: 800,
			};
			function computeSetup4Positions() {
				const centerTarget = new THREE.Vector3(0, 0, 300);
				const dz = setup4.heightZ;
				const D = Math.max(1e-6, setup4.distanceToCenter);
				// Prefer geometrically consistent placement: all three cameras lie on a circle of radius D
				// around the grid center. Left/Right are rotated by ±ang from the center camera direction.
				let ang = (setup4.flareAngleDeg * Math.PI) / 180;
				// If distanceBetween is set, derive ang to match the chord length B = 2*D*sin(ang)
				if (setup4.distanceBetween && setup4.distanceBetween > 0) {
					const s = Math.min(
						1.0,
						Math.max(0.0, setup4.distanceBetween / (2 * D))
					);
					ang = Math.asin(s);
				}
				const a0 = -Math.PI / 2; // center camera sits at (0, -D, dz)
				const baseC = new THREE.Vector3(D * Math.cos(a0), D * Math.sin(a0), dz);
				const posL = new THREE.Vector3(
					D * Math.cos(a0 + ang),
					D * Math.sin(a0 + ang),
					dz
				);
				const posR = new THREE.Vector3(
					D * Math.cos(a0 - ang),
					D * Math.sin(a0 - ang),
					dz
				);
				return [posL, baseC, posR].map((p) => ({
					pos: p,
					dir: centerTarget.clone().sub(p).normalize(),
				}));
			}
			let selectedPOV = null;
			// Setup 3 (customizable around circle)
			let setup3 = {
				heightZ: 120,
				// defaults approximate prior ring layout (R=1200, delta=120deg → arc ≈ 2513)
				arcDistance: 2513,
				distanceToCenter: 1200,
			};
			function computeSetup3Positions() {
				const R = Math.max(1e-6, setup3.distanceToCenter);
				const delta = setup3.arcDistance / R;
				const z = setup3.heightZ;
				const centerTarget = new THREE.Vector3(0, 0, 300);
				const c = new THREE.Vector3(R * Math.cos(0), R * Math.sin(0), z);
				const l = new THREE.Vector3(
					R * Math.cos(delta),
					R * Math.sin(delta),
					z
				);
				const r = new THREE.Vector3(
					R * Math.cos(-delta),
					R * Math.sin(-delta),
					z
				);
				return [l, c, r].map((p) => ({
					pos: p,
					dir: centerTarget.clone().sub(p).normalize(),
				}));
			}
			function makeArrows() {
				// Setup 3 arrows
				computeSetup3Positions().forEach((entry, i) => {
					const a = new THREE.ArrowHelper(
						entry.dir,
						entry.pos.clone(),
						70,
						0x00aaff,
						14,
						7
					);
					a.userData = { setup: 'setup3', index: i };
					scene.add(a);
					setup3Arrows.push(a);
				});
				// Setup 4 custom arrows
				computeSetup4Positions().forEach((entry, i) => {
					const a = new THREE.ArrowHelper(
						entry.dir,
						entry.pos.clone(),
						60,
						0xff4444,
						12,
						6
					);
					a.userData = { setup: 'setup4', index: i };
					scene.add(a);
					setup4Arrows.push(a);
				});
			}
			makeArrows();
			function setSetup3POV(i) {
				const pos =
					computeSetup3Positions()[i]?.pos ||
					new THREE.Vector3(1200, 0, setup3.centerHeightZ);
				camera.position.copy(pos);
				camera.up.set(0, 0, 1);
				camera.lookAt(center);
				controls.target.copy(center);
				controls.update();
				selectedPOV = { setup: 'setup3', index: i };
			}
			function updateArrowVisibility() {
				if (!selectedPOV) {
					setup3Arrows.forEach((a) => (a.visible = true));
					setup4Arrows.forEach((a) => (a.visible = true));
					return;
				}
				setup3Arrows.forEach((a) => (a.visible = false));
				setup4Arrows.forEach((a) => (a.visible = false));
				const threshold = 50;
				let base = null;
				if (selectedPOV.setup === 'setup3') {
					base = setup3Arrows[selectedPOV.index]?.position || null;
				}
				if (selectedPOV.setup === 'setup4') {
					base = setup4Arrows[selectedPOV.index]?.position || null;
				}
				if (base && camera.position.distanceTo(base) > threshold) {
					setup3Arrows.forEach((a) => (a.visible = true));
					setup4Arrows.forEach((a) => (a.visible = true));
				}
			}

			// --- Track playback ---
			let lastTs = performance.now();
			// With unified HUD, no layout adjustments are necessary
			function layoutPanels() {}
			function animate() {
				requestAnimationFrame(animate);
				const nowTs = performance.now();
				const dt = (nowTs - lastTs) / 1000.0;
				lastTs = nowTs;
				// File-based multi-track playback (paused until Start)
				if (fileTracks.length > 0) {
					for (let i = 0; i < fileTracks.length; i++) {
						const tr = fileTracks[i];
						if (!tr || tr.length === 0) continue;
						const p = tr[Math.min(fileIdx, tr.length - 1)];
						if (p && fileActors[i]) fileActors[i].position.set(p.x, p.y, p.z);
					}
					// advance at target playback fps only when playing
					if (filePlaying) {
						fileAcc += dt;
						const step = 1.0 / Math.max(1, filePlaybackFps);
						while (fileAcc >= step) {
							if (fileIdx < fileMaxLen - 1) fileIdx += 1;
							fileAcc -= step;
						}
					}
				}
				// Simulation playback
				if (simPlaying && simActors.length > 0) {
					const elapsed = (performance.now() - simStart) / 1000.0;
					let t = Math.min(1.0, Math.max(0.0, elapsed / simDurationSec));
					for (const a of simActors) {
						const p = a.pathFn(t);
						if (p) a.mesh.position.copy(p);
					}
					if (t >= 1.0) {
						simPlaying = false;
						flash('#ff3355'); // end marker
					}
				}
				// (no legacy single-dot tracking)
				updateArrowVisibility();
				controls.update();
				renderer.render(scene, camera);
			}
			animate();

			document.getElementById('file').addEventListener('change', (ev) => {
				const files = ev.target.files;
				if (!files || files.length === 0) return;
				// Stop simulation playback and reset state
				clearSimActors();
				simPlaying = false;
				for (let i = 0; i < files.length; i++) {
					const f = files[i];
					const reader = new FileReader();
					reader.onload = () => {
						try {
							const data = JSON.parse(reader.result);
							if (!addTracksFromData(f.name.replace(/\.json$/i, ''), data)) {
								alert('Unsupported track format in ' + f.name);
							}
							const includeSimRow = document.getElementById('includeSimRow');
							if (includeSimRow) includeSimRow.style.display = 'block';
						} catch (e) {
							alert('Bad JSON in ' + f.name);
						}
					};
					reader.readAsText(f);
				}
			});

			// POV buttons removed for Setup 1 & 2 (deleted)
			// Removed static Setup 3 handlers; dynamic controls below
			// Add customizable Setup 3 + Setup 4 controls into HUD
			(function addSetupControls() {
				const hud = document.getElementById('hud');
				const title3 = document.createElement('div');
				title3.textContent = 'Setup 1 (customizable)';
				title3.style.margin = '8px 0';
				title3.style.fontSize = '12px';
				title3.style.color = '#888';
				hud.appendChild(title3);
				const params3 = document.createElement('div');
				params3.style.display = 'grid';
				params3.style.gridTemplateColumns = 'auto auto';
				params3.style.gap = '4px 6px';
				function addParam3(label, key) {
					const l = document.createElement('label');
					l.textContent = label;
					const inp = document.createElement('input');
					inp.type = 'number';
					inp.step = '1';
					inp.value = setup3[key];
					inp.onchange = () => {
						setup3[key] = parseFloat(inp.value);
						// rebuild arrows
						setup3Arrows.forEach((a) => a.parent && a.parent.remove(a));
						setup3Arrows.length = 0;
						computeSetup3Positions().forEach((entry, i) => {
							const a = new THREE.ArrowHelper(
								entry.dir,
								entry.pos.clone(),
								70,
								0x00aaff,
								14,
								7
							);
							a.userData = { setup: 'setup3', index: i };
							scene.add(a);
							setup3Arrows.push(a);
						});
						updateArrowVisibility();
					};
					params3.appendChild(l);
					params3.appendChild(inp);
				}
				addParam3('Height Z', 'heightZ');
				addParam3('Arc distance (along circle)', 'arcDistance');
				addParam3('Distance to center (R)', 'distanceToCenter');
				hud.appendChild(params3);
				const row3 = document.createElement('div');
				row3.style.marginTop = '6px';
				function addBtn3(name, idx) {
					const b = document.createElement('button');
					b.className = 'setup3-btn';
					b.textContent = name;
					b.onclick = () => {
						const p = computeSetup3Positions()[idx]?.pos;
						if (p) {
							camera.position.copy(p);
							camera.up.set(0, 0, 1);
							camera.lookAt(0, 0, 300);
							controls.target.set(0, 0, 300);
							controls.update();
							selectedPOV = { setup: 'setup3', index: idx };
							updateArrowVisibility();
						}
					};
					row3.appendChild(b);
				}
				addBtn3('POV 1', 0);
				addBtn3('POV 2', 1);
				addBtn3('POV 3', 2);
				hud.appendChild(row3);

				// (per-setup save removed; unified save provided at bottom)

				const title4 = document.createElement('div');
				title4.textContent = 'Setup 2 (customizable)';
				title4.style.margin = '8px 0';
				title4.style.fontSize = '12px';
				title4.style.color = '#888';
				hud.appendChild(title4);
				const params = document.createElement('div');
				params.style.display = 'grid';
				params.style.gridTemplateColumns = 'auto auto';
				params.style.gap = '4px 6px';
				function addParam(label, key) {
					const l = document.createElement('label');
					l.textContent = label;
					const inp = document.createElement('input');
					inp.type = 'number';
					inp.step = '1';
					inp.value = setup4[key];
					inp.onchange = () => {
						setup4[key] = parseFloat(inp.value);
						// Rebuild arrows
						setup4Arrows.forEach((a) => a.parent && a.parent.remove(a));
						setup4Arrows.length = 0;
						computeSetup4Positions().forEach((entry, i) => {
							const a = new THREE.ArrowHelper(
								entry.dir,
								entry.pos.clone(),
								60,
								0xff4444,
								12,
								6
							);
							a.userData = { setup: 'setup4', index: i };
							scene.add(a);
							setup4Arrows.push(a);
						});
						updateArrowVisibility();
					};
					params.appendChild(l);
					params.appendChild(inp);
				}
				addParam('Height Z', 'heightZ');
				addParam('Distance between (B)', 'distanceBetween');
				addParam('Flare angle (deg)', 'flareAngleDeg');
				addParam('Distance to center (D)', 'distanceToCenter');
				hud.appendChild(params);
				const row = document.createElement('div');
				row.style.marginTop = '6px';
				function addBtn(name, idx) {
					const b = document.createElement('button');
					b.className = 'setup4-btn';
					b.textContent = name;
					b.onclick = () => {
						const p =
							setup4Arrows[idx]?.position ||
							new THREE.Vector3(0, -setup4.distanceToCenter, setup4.heightZ);
						camera.position.copy(p);
						camera.up.set(0, 0, 1);
						camera.lookAt(0, 0, 300);
						controls.target.set(0, 0, 300);
						controls.update();
						selectedPOV = { setup: 'setup4', index: idx };
						updateArrowVisibility();
					};
					row.appendChild(b);
				}
				addBtn('POV 1', 0);
				addBtn('POV 2', 1);
				addBtn('POV 3', 2);
				hud.appendChild(row);
				// (per-setup save removed; unified save provided at bottom)
				// Unified save button (bottom of HUD)
				const saveAllBtn = document.createElement('button');
				saveAllBtn.id = 'saveAllSetupsBtn';
				saveAllBtn.className = 'save-btn';
				saveAllBtn.textContent = 'Save Camera Configs';
				saveAllBtn.style.marginTop = '10px';
				saveAllBtn.onclick = async () => {
					const s1 = computeSetup3Positions();
					const s2 = computeSetup4Positions();
					const cams = [];
					s1.forEach((e, i) =>
						cams.push({
							name: `setup1_${i + 1}`,
							position: [e.pos.x, e.pos.y, e.pos.z],
							forward: [e.dir.x, e.dir.y, e.dir.z],
							up: [0, 0, 1],
							fov_deg: 70,
						})
					);
					s2.forEach((e, i) =>
						cams.push({
							name: `setup2_${i + 1}`,
							position: [e.pos.x, e.pos.y, e.pos.z],
							forward: [e.dir.x, e.dir.y, e.dir.z],
							up: [0, 0, 1],
							fov_deg: 70,
						})
					);
					// Try posting to local save server first; fall back to download if it fails
					const payload = { cameras: cams };
					let posted = false;
					try {
						const resp = await fetch('http://127.0.0.1:8787/save_cams', {
							method: 'POST',
							headers: { 'Content-Type': 'application/json' },
							body: JSON.stringify(payload),
						});
						if (resp.ok) {
							flash('#66ff66');
							posted = true;
						} else {
							console.warn('Save server responded with status', resp.status);
						}
					} catch (err) {
						console.warn(
							'Save server not reachable; falling back to download',
							err
						);
					}
					if (!posted) {
						const blob = new Blob([JSON.stringify(payload, null, 2)], {
							type: 'application/json',
						});
						const url = URL.createObjectURL(blob);
						const a = document.createElement('a');
						a.href = url;
						a.download = 'cam_config.json';
						a.click();
						URL.revokeObjectURL(url);
						flash('#ffaa33');
					}
				};
				hud.appendChild(saveAllBtn);
			})();
			document.getElementById('start').onclick = () => startFlight();
			document
				.getElementById('scenario')
				.addEventListener('change', layoutPanels);
			const simChk = document.getElementById('includeSim');
			if (simChk) simChk.addEventListener('change', layoutPanels);
			const pathsChk = document.getElementById('showPaths');
			if (pathsChk)
				pathsChk.addEventListener('change', () => {
					buildFilePaths();
					buildSimPaths();
				});

			// Default camera
			camera.position.set(0, -900, 200);
			camera.lookAt(0, 0, 300);

			addEventListener('resize', () => {
				camera.aspect = innerWidth / innerHeight;
				camera.updateProjectionMatrix();
				renderer.setSize(innerWidth, innerHeight);
				layoutPanels();
			});
			// Map Cmd+S to unified save
			addEventListener('keydown', (ev) => {
				if (ev.metaKey && (ev.key === 's' || ev.key === 'S')) {
					ev.preventDefault();
					const btn = document.getElementById('saveAllSetupsBtn');
					if (btn) btn.click();
				}
			});
			layoutPanels();
		</script>
	</body>
</html>
